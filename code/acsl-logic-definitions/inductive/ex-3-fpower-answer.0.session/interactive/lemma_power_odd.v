(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require bool.Bool.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require real.Real.
Require real.RealInfix.
Require real.FromInt.
Require map.Map.

Parameter eqb:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Init.Datatypes.bool.

Axiom eqb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a),
  ((x = y) -> ((eqb x y) = Init.Datatypes.true)) /\
  (~ (x = y) -> ((eqb x y) = Init.Datatypes.false)).

Parameter neqb:
  forall {a:Type} {a_WT:WhyType a}, a -> a -> Init.Datatypes.bool.

Axiom neqb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (x:a) (y:a),
  (~ (x = y) -> ((neqb x y) = Init.Datatypes.true)) /\
  ((x = y) -> ((neqb x y) = Init.Datatypes.false)).

Parameter zlt: Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom zlt'def :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((x < y)%Z -> ((zlt x y) = Init.Datatypes.true)) /\
  (~ (x < y)%Z -> ((zlt x y) = Init.Datatypes.false)).

Parameter zleq:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom zleq'def :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((x <= y)%Z -> ((zleq x y) = Init.Datatypes.true)) /\
  (~ (x <= y)%Z -> ((zleq x y) = Init.Datatypes.false)).

Parameter rlt:
  Reals.Rdefinitions.R -> Reals.Rdefinitions.R -> Init.Datatypes.bool.

Axiom rlt'def :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R),
  ((x < y)%R -> ((rlt x y) = Init.Datatypes.true)) /\
  (~ (x < y)%R -> ((rlt x y) = Init.Datatypes.false)).

Parameter rleq:
  Reals.Rdefinitions.R -> Reals.Rdefinitions.R -> Init.Datatypes.bool.

Axiom rleq'def :
  forall (x:Reals.Rdefinitions.R) (y:Reals.Rdefinitions.R),
  ((x <= y)%R -> ((rleq x y) = Init.Datatypes.true)) /\
  (~ (x <= y)%R -> ((rleq x y) = Init.Datatypes.false)).

(* Why3 assumption *)
Definition real_of_int (x:Numbers.BinNums.Z) : Reals.Rdefinitions.R :=
  BuiltIn.IZR x.

Axiom c_euclidian :
  forall (n:Numbers.BinNums.Z) (d:Numbers.BinNums.Z), ~ (d = 0%Z) ->
  (n = (((ZArith.BinInt.Z.quot n d) * d)%Z + (ZArith.BinInt.Z.rem n d))%Z).

Axiom cmod_remainder :
  forall (n:Numbers.BinNums.Z) (d:Numbers.BinNums.Z),
  ((0%Z <= n)%Z -> (0%Z < d)%Z ->
   (0%Z <= (ZArith.BinInt.Z.rem n d))%Z /\ ((ZArith.BinInt.Z.rem n d) < d)%Z) /\
  ((n <= 0%Z)%Z -> (0%Z < d)%Z ->
   ((-d)%Z < (ZArith.BinInt.Z.rem n d))%Z /\
   ((ZArith.BinInt.Z.rem n d) <= 0%Z)%Z) /\
  ((0%Z <= n)%Z -> (d < 0%Z)%Z ->
   (0%Z <= (ZArith.BinInt.Z.rem n d))%Z /\
   ((ZArith.BinInt.Z.rem n d) < (-d)%Z)%Z) /\
  ((n <= 0%Z)%Z -> (d < 0%Z)%Z ->
   (d < (ZArith.BinInt.Z.rem n d))%Z /\ ((ZArith.BinInt.Z.rem n d) <= 0%Z)%Z).

Axiom cdiv_neutral :
  forall (a:Numbers.BinNums.Z), ((ZArith.BinInt.Z.quot a 1%Z) = a).

Axiom cdiv_inv :
  forall (a:Numbers.BinNums.Z), ~ (a = 0%Z) ->
  ((ZArith.BinInt.Z.quot a a) = 1%Z).

Axiom cdiv_closed_remainder :
  forall (a:Numbers.BinNums.Z) (b:Numbers.BinNums.Z) (n:Numbers.BinNums.Z),
  (0%Z <= a)%Z -> (0%Z <= b)%Z ->
  (0%Z <= (b - a)%Z)%Z /\ ((b - a)%Z < n)%Z ->
  ((ZArith.BinInt.Z.rem a n) = (ZArith.BinInt.Z.rem b n)) -> (a = b).

(* Why3 assumption *)
Inductive P_is_power: Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  Numbers.BinNums.Z -> Prop :=
  | Q_zero : forall (x:Numbers.BinNums.Z), P_is_power x 0%Z 1%Z
  | Q_N :
      forall (x:Numbers.BinNums.Z) (n:Numbers.BinNums.Z)
        (r:Numbers.BinNums.Z),
      (0%Z < n)%Z -> P_is_power x ((-1%Z)%Z + n)%Z r ->
      P_is_power x n (r * x)%Z.

Axiom Q_power_even :
  forall (x:Numbers.BinNums.Z) (n:Numbers.BinNums.Z) (r:Numbers.BinNums.Z),
  (0%Z <= n)%Z -> P_is_power (x * x)%Z n r -> P_is_power x (2%Z * n)%Z r.

(* Why3 goal *)
Theorem wp_goal :
  forall (i:Numbers.BinNums.Z) (i1:Numbers.BinNums.Z) (i2:Numbers.BinNums.Z),
  (0%Z <= i)%Z -> P_is_power (i2 * i2)%Z i i1 ->
  P_is_power i2 (1%Z + (2%Z * i)%Z)%Z (i1 * i2)%Z.
(* Why3 intros i i1 i2 h1 h2. *)
Proof.
  Require Import Psatz.

  intros.
  constructor ; try lia.
  replace (- (1) + (1 + 2 * i))%Z with (2 * i)%Z by lia.
  apply Q_power_even ; auto.
Qed.

