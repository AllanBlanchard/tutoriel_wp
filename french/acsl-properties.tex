
Depuis le début de ce tutoriel, nous avons vu divers prédicats et fonctions
logiques qui sont fournis par défaut en ACSL : \CodeInline{\textbackslash{}valid}, \CodeInline{\textbackslash{}valid\_read},
\CodeInline{\textbackslash{}separated}, \CodeInline{\textbackslash{}old} et \CodeInline{\textbackslash{}at}. Il en existe bien sûr d'autres, mais
nous ne les présenterons pas un à un ; le lecteur pourra se référer à
\externalLink{la documentation (ACSL implementation)}{https://frama-c.com/html/get-frama-c.html}
pour cela (à noter : tout n'est pas nécessairement supporté par WP).



ACSL permet de faire plus que « simplement » spécifier notre code. Nous
pouvons définir nos propres prédicats, fonctions, relations, etc. Le but est de
pouvoir abstraire nos spécifications. Cela nous permet de les factoriser (par
exemple en définissant ce qu'est un tableau valide), ce qui a deux effets
positifs : d'abord nos spécifications deviennent plus lisibles donc
plus faciles à comprendre, mais cela permet également de réutiliser des preuves
déjà faites et donc de faciliter la preuve de nouveaux programmes.


\begin{levelTwo}
  {Types primitifs supplémentaires}
  {some-logical-types}
\end{levelTwo}

\begin{levelTwo}
  {Prédicats}
  {predicates}
\end{levelTwo}

\begin{levelTwo}
  {Fonctions logiques}
  {functions}
\end{levelTwo}

\begin{levelTwo}
  {Lemmes}
  {lemmas}
\end{levelTwo}



\horizontalLine



Dans cette partie, nous avons vu les constructions de ACSL qui nous permettent
de factoriser un peu nos spécifications et d'exprimer des propriétés générales
pouvant être utilisées par les prouveurs pour faciliter leur travail.



Toutes les techniques expliquées dans cette partie sont sûres, au sens où
elles ne permettent \textit{a priori} pas de fausser la preuve avec des définitions
fausses ou contradictoires. En tout cas, si la spécification n'utilise que ce
type de constructions et que chaque lemme, chaque précondition (aux points
d'appel), chaque postcondition, chaque assertion, chaque variant et chaque
invariant est correctement prouvé, le code est juste.



Parfois ces constructions ne sont pas suffisantes pour exprimer toutes nos
propriétés ou pour prouver nos programmes. Les prochaines constructions que nous
verrons ajouteront de nouvelles possibilités à ce sujet, mais il
faudra se montrer prudent dans leur usage, car des erreurs pourraient nous
permettre de créer des hypothèses fausses ou d'altérer le programme que nous
vérifions.
