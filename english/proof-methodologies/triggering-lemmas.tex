There are different levels of automation for the verification of programs. From
tools that are completely automatic, like for example abstract interpreters that
do not require any help from the human, to interactive tools, like proof
assistants where we write the proof mostly by hand and the tools is just there
to check that we do it right.



Tools like WP (any many others like Why3, Spark, ...) tend to maximize
automation. However, the more the properties we want to prove are complex, the
harder it will be to get automatically the proof. Thus, we often need to help
the tools in order to achieve the verification. This is done by providing more
annotations to help the verification condition generation process. Adding loop
invariant is for example a way to be able to produce an inductive reasoning
about a loop while automatic provers are generally bad at this kind of task.



This kind of technique has been called ``auto-active'' verification. This word
is the contraction of ``automatic'' and ``interactive''. It is automatic in the
sense that most of the proof is performed by automatic tools, but it is also
somewhat interactive since as a user, we manually provide information to the
tools.



In this section, we will see in more details how we can use assertions to guide
the proofs. By adding assertions, we create some base of knowledge (properties
that are known to be true) that are collected by the verification condition
generator during the WP computation process and that are then given to the
automatic solvers that consequently have more information and thus can
potentially prove more complex properties.



\levelThreeTitle{Proof context}



In order to understand what is exactly the benefit of adding assertions in
annotations of a program, let us first have a closer look to the proof goals
generated by WP from the annotated source code and how assertions are taken in
account. For this, we will consider the following predicate (one can recognize
Pythagoras' theorem):



\CodeBlockInput[1][4]{c}{context.c}



Let us first consider this example:



\CodeBlockInput[6][16]{c}{context.c}



Here, we have specified a precondition that is complex enough so that WP cannot
directly guess the values in input of the function. In fact, the values are
exactly: \CodeInline{*x == 3}, \CodeInline{*y == 4} and \CodeInline{*z == 5}.
Now, if we have a look to proof goal generated for our first assertion, we can
see this (be sure to select the view ``Full Context'' or ``Raw Obligation'' -
they are not exactly the same but quite similar, the former is just slightly
pretty printed):


\image{context_e1_a1}


That is to say the different constraint we have stated as a precondition to the
function that slightly different (some more properties have been specified and
the values are not exactly the same). What is more interesting is having a look
to the goal generated for the second assertion (note that we have edited all the
remaining screenshots in this section in order to focus on what is important
here):


\image{context_e1_a2}



Note that WP only collects what we can find on the different paths that allows
to reach the assertion. For example, if we modify the code such that the path
to the assertion jumps over the first assertion, it does not appear in the goal.



\CodeBlockInput[26][31]{c}{context.c}


\image{context_e1p_a2}


Now let us modify the example a little bit in order to illustrate how assertions
can change the way to prove a program. For example, let us first modify the
different memory locations (doubling each value) and check that the resulting
triangle is a right triangle.


\CodeBlockInput[34][47]{c}{context.c}



\image{context_e2}



Here, the solver will likely unfold the predicate and directly check that the
property is true, indeed from the information we have in this goal, we do not
have so much information that would allows us to produce this proof. Now, let
us bring new information in annotation:



\CodeBlockInput[34][47]{c}{context.c}



Here, we first prove that if we multiply by 2 each of the values, the predicate
is true for these new values. The solver will in fact basically solve the same
problem at first, but that is not what we want to point out now. Then, we
re-express the values we have modified in another way: we show that all of them
have been multiplied by 2. Finally, we can have a look to the generated proof
goal at the end of the function:



\image{context_e3}



While we have to prove exactly the same property as before (with a bit of
renaming), we can see that we have here another way to prove it. Indeed, by
just combining these set of properties:


\begin{CodeBlock}{text}
(* Assertion *)
Have: P_rectangle(x_10, x_8, x_5).
(* Assertion *)
Have: x_9 = x_10.
(* Assertion *)
Have: x_6 = x_8.
(* Assertion *)
Have: x_3 = x_5.
\end{CodeBlock}


It is easy to deduce:


\begin{CodeBlock}{text}
Prove: P_rectangle(x_9, x_6, x_3).
\end{CodeBlock}


By just replacing the values \CodeInline{x\_9}, \CodeInline{x\_6} and
\CodeInline{x\_3}. So the solver could use this to avoid unfolding the
predicate. However, it will not necessarily do it: SMT solvers are based on
heuristic methods, so we can just provide them properties and hope that they
will use it.



Here, the property is simple to prove, so it was not really necessary to add
assertion (and make more effort). In other case, as we will see now, we have to
give the right information so that they will find what they need to finish the
proof.




\levelThreeTitle{Triggering lemmas}





\levelThreeTitle{A more complex example: sort, again}



We will again illustrate the use of axiomatic definitions with a sort
function. This time, we will prove the insertion sort function:



\CodeBlockInput{c}{insert_sort.c}


The \CodeInline{insertion\_sort} function visits each value, from the beginning
of the array, to the end. For each of value $v$, it is inserted (using the
function \CodeInline{insert}) at the right place in the range of the already
sorted values (at the beginning of the array), by shifting them until we meet a
value that is smaller than $v$ or the first cell of the array.




We want to prove the same postcondition as we already proved for the selection
sort, that is: we want to create a sorted permutation of the original values.
Again, each iteration of the loop must ensure that the new configuration is a
permutation of the original values, and that the range from the beginning to
the current visited cell is sorted. All these properties are ensured by the
\CodeInline{insert} function. If we give a closer look to this function, we can
see that it records the value to insert (which is at the end of the range) in
the variable \CodeInline{value} and starting from this last position it shifts
all value until we meet a value that is smaller than the one we want to insert
or the first cell of the array.




First, let us provide a suitable contract and loop invariant to insertion sort
function. The contract is equivalent to the one provided to the selection sort.
Note however that the invariant is weaker: we do not needed the values that are
still not visited to be greater than the visited ones: we insert each value at
the right place.



\CodeBlockInput[64][81]{c}{insert_sort-contract.c}



Now, we can provide a contract to the insert function. The function requires
that the first part of the range is already sorted, and in exchange, it
guarantees to provide a range with one more value, that is still sorted and
is permutation of the original range:



\CodeBlockInput[43][61]{c}{insert_sort-contract.c}



Then, we need to provide a suitable invariant to the loop of the
\CodeInline{insert} function. And this time, we can see that we are in trouble.
Indeed, our inductive definition of the permutation specifies three cases: a
range is permutation of itself, or two (and only two) values have been swapped,
or the permutation is transitive. But none of this cases can be applied to our 
\CodeInline{insert} function, since the shifted range is not obtained by
successively exchanging values, and that the other cases obviously do not apply
here.



Thus, we need to find a better definition to the notion of permutation. We can
notice that what we really need to provide is a way to say ``each value that
was previously in the array is still in the array and if several values were
equivalent, the number of occurrence of these values does not change''. And in
fact, this last part of the expression is enough to express our permutation.
A permutation of range is a range such that for all value, the number of
occurrences of this value in the array does not change from a program point to
another:



\CodeBlockInput[37][41]{c}{insert_sort-proved.c}



Starting from this definition, we can directly define lemmas that can help us
to deduce that some array that respect some properties from a label to another
is indeed a permutation. For example, that would be possible for the definition
of the case \CodeInline{Swap} in our previous inductive definition. And it is
of course also possible for our shifted range.




Let us determine what are the required lemmas by first considering the function
\CodeInline{insert\_sort}. The only property that is not proved is the invariant
of the loop that expresses the fact that the array is a permutation of the
original array. How can we deduce it? (We will consider the proofs of the lemmas
later).




We can observe two facts: the first part of the array (from \CodeInline{beg} to
\CodeInline{i+1}) is a permutation of the values that were present in the array
at the beginning of the iteration (by the contract of the \CodeInline{insert}
function). The second part (from \CodeInline{i+1} to \CodeInline{end}) is
unchanged, so this is also a permutation of the values present at the beginning
of the iteration. While the first property is easily deduced, we can see that
the second one is not:



\begin{CodeBlock}{c}
  /*@
    loop invariant beg+1 <= i <= end ;
    loop invariant sorted(a, beg, i) ;
    loop invariant permutation{Pre, Here}(a,beg,end);
    loop assigns a[beg .. end-1], i ;
    loop variant end-i ;
  */
  for(size_t i = beg+1; i < end; ++i) {
    //@ ghost L:
    insert(a, beg, i);
    //@ assert permutation{L, Here}(a, beg, i+1); // PROVED
    //@ assert permutation{L, Here}(a, i+1, end); // NOT PROVED
  }
\end{CodeBlock}

So we need a first lemma for this property, we use a predicate
\CodeInline{shifted} to define \CodeInline{unchanged}, we will explain why
later.

\CodeBlockInput[53][60]{c}{insert_sort-proved.c}
\CodeBlockInput[67][70]{c}{insert_sort-proved.c}

And now, we can verify that those two sub-arrays are permutations:


\CodeBlockInput[127][140]{c}{insert_sort-proved.c}


Thus, since those two parts are permutations, the global array is a permutation
of the values present at the beginning of the iteration. However, this is not
directly proved, so we also need a lemma for this:



\CodeBlockInput[75][81]{c}{insert_sort-proved.c}


And now we can deduce that a loop iteration produces a permutation:



\begin{CodeBlock}{c}
    //@ ghost L:
    insert(a, beg, i);
    //@ assert permutation{L, Here}(a, beg, i+1);
    //@ assert unchanged{L, Here}(a, i+1, end);
    //@ assert permutation{L, Here}(a, i+1, end);
    //@ assert permutation{L, Here}(a, beg, end); // PROVED
\end{CodeBlock}



Finally, we need to add one more information, the permutation of a permutation
is also a permutation:



\CodeBlockInput[42][47]{c}{insert_sort-proved.c}



Now, we can have a closer look to the insertion function, by first considering
how to maintain that the function produces a permutation.




It shifts the different elements to the left until it reaches the beginning of
the array or an element that is smaller than the element to insert which is
initially at the end of the range, and is insert at the reached position. The
cells from the beginning of the array to the location of insertion are left
unchanged, so this is a permutation. We have a lemma for this, but we also have
to state that the values are unchanged as an invariant of the loop. The second
part of the array is a permutation because we rotate the elements, we need a
lemma to express this and to state at least that the element are shifted by the
loop as an invariant. Finally the union of the two permutations is a
permutation, and we also have a lemma for this.



So first, we can give a suitable invariant for the permutation:

\begin{itemize}
\item we provide the bounds of \CodeInline{i}
\item we state that the first part is left unchanged
\item we state that the last part is shifted to the left
\end{itemize}

as well as some assertions that we want to be verified.



\begin{CodeBlock}{c}
  /*@
    loop invariant beg <= i <= last ;
    loop invariant \forall integer k ; beg <= k <= i    ==> a[k] == \at(a[k], Pre) ;
    loop invariant \forall integer k ; i+1 <= k <= last ==> a[k] == \at(a[k-1], Pre) ;

    loop assigns i, a[beg .. last] ;
    loop variant i ;
  */
  while(i > beg && a[i - 1] > value){
    a[i] = a[i - 1] ;
    --i ;
  }

  a[i] = value ;

  //@ assert unchanged{Pre, Here}(a, beg, i) ;   // PROVED
  //@ assert permutation{Pre, Here}(a, beg, i) ; // PROVED

  //@ assert permutation{Pre, Here}(a, i, last+1) ; // NOT PROVED
\end{CodeBlock}


Then, for the last assertion, we need a lemma about the rotation of the
elements:


\CodeBlockInput[56][60]{c}{insert_sort-proved.c}
\CodeBlockInput[71][74]{c}{insert_sort-proved.c}



\levelThreeTitle{Exercises}
