There are different levels of automation for the verification of programs. From
tools that are completely automatic, like for example abstract interpreters that
do not require any help from the human (or at least not so much), to interactive
tools, like proof assistants where we write the proof mostly by hand and the
tools is just there to check that we do it right.



Tools like WP (any many others like Why3, Spark, ...) tend to maximize
automation. However, the more the properties we want to prove are complex, the
harder it will be to get automatically the proof. Thus, we often need to help
the tools in order to achieve the verification. This is done by providing more
annotations to help the verification condition generation process. Adding a loop
invariant is for example a way to be able to produce an inductive reasoning
about a loop while automatic provers are generally bad at this kind of task.



This kind of technique has been called ``auto-active'' verification. This word
is the contraction of ``automatic'' and ``interactive''. It is automatic in the
sense that most of the proof is performed by automatic tools, but it is also
somewhat interactive since as users, we manually provide information to the
tools.



In this section, we will see in more details how we can use assertions to guide
the proofs. By adding assertions, we create some base of knowledge (properties
that are known to be true) that are collected by the verification condition
generator during the WP computation process and that are then given to the
automatic solvers that consequently have more information and thus can
potentially prove more complex properties.



\levelThreeTitle{Proof context}



In order to understand what is exactly the benefit of adding assertions in
annotations of a program, let us first have a closer look at the verification
condition generated by WP from the annotated source code and how assertions are
taken into account. For this, we consider the following predicate (one can
recognize Pythagoras' theorem):



\CodeBlockInput[5][8]{c}{context.c}



Let us first consider this example:



\CodeBlockInput[10][20]{c}{context.c}



Here, we have specified a precondition that is complex enough so that WP cannot
directly guess the values in input of the function. In fact, the values are
exactly: \CodeInline{*x == 3}, \CodeInline{*y == 4} and \CodeInline{*z == 5}.
Now, if we have a look at the verification condition generated for our first
assertion, we can see this (be sure to select the view ``Full Context'' or
``Raw Obligation'' - they are not exactly the same but quite similar, the former
is just slightly pretty printed):


\image{context_e1_a1}


That is to say the different constraints we have stated as a precondition to the
function (note that the values are not exactly the same, and some more properties
have been specified). What is more interesting is having a look
at the verification condition generated for the second assertion (note that we
have edited all the remaining screenshots in this section in order to focus on
what is important, the other properties can just be ignored in our case):


\image{context_e1_a2}


Here, we can see that for the proof of the second assertion, WP has collected
and added the first assertion to the assumptions. Thus, WP considers that SMT
solvers can assume this assertion. That means that they can rely on it, but also
that it should be proved to be sure that the current verification condition is
verified.


Note that WP only collects what we can find on the different paths that allows
to reach the assertion. For example, if we modify the code such that the path
to the assertion jumps over the first assertion, it does not appear in the
verification condition.



\CodeBlockInput[30][35]{c}{context.c}


\image{context_e1p_a2}


Now let us modify the example a bit in order to illustrate how assertions
can change the way to prove a program. For example, let us first modify the
different memory locations (doubling each value) and check that the resulting
triangle is a right triangle.


\CodeBlockInput[38][51]{c}{context.c}



\image{context_e2}



Here, the solver will likely unfold the predicate and directly check that the
property is true, indeed from the information we have in this verification
condition, we do not really have any other knowledge that would allow us to
produce this proof in another way. Now, let us bring new information in
annotation:



\CodeBlockInput[53][72]{c}{context.c}



We first prove that if we multiply by 2 each of the values, the predicate
is true for the new values. The solver in fact basically solves the same
problem at first, but this is not what we want to point out now. Then, we
re-express the values we have modified in another way: we show that all of them
have been multiplied by 2. Now, we can have a new look at the generated
verification condition for the last assertion:



\image{context_e3}



While we have to prove exactly the same property as before (with a bit of
renaming), we can see that we have here another way to prove it. Indeed, by
just combining this set of properties:


\begin{CodeBlock}{text}
(* Assertion *)
Have: P_rectangle(x_10, x_8, x_5).
(* Assertion *)
Have: x_9 = x_10.
(* Assertion *)
Have: x_6 = x_8.
(* Assertion *)
Have: x_3 = x_5.
\end{CodeBlock}


It is easy to deduce:


\begin{CodeBlock}{text}
Prove: P_rectangle(x_9, x_6, x_3).
\end{CodeBlock}


By just replacing the values \CodeInline{x\_9}, \CodeInline{x\_6} and
\CodeInline{x\_3}. So the solver could use this to avoid unfolding the
predicate. However, it will not necessarily do it: SMT solvers are based on
heuristic methods, so we can just provide them properties and hope that they
will use it.



Here, the property is simple to prove, so it was not really necessary to add
assertions (and make more effort). In other cases, as we will see now, we have
to give the right information so that they will find what they need to finish
the proof.



\levelThreeTitle{Triggering lemmas}


We often use assertions to express properties that precisely correspond to one
or all of the premises of a lemma or to its conclusion. By doing this, we
maximize the chances that the SMT solver ``recognize'' that what we have written
corresponds to a particular lemma and that it should use it.



Let us illustrate this use with the following example. We use axioms and not
lemmas as they are used exactly the same way by WP. First consider the following
axiomatic definition. We define  two predicates \CodeInline{P} and
\CodeInline{Q} about a particular memory location \CodeInline{x}. We have two
axioms: \CodeInline{ax\_1} that states that if \CodeInline{P(x)} is true, then
\CodeInline{Q(x)} is true, and a second axiom \CodeInline{ax\_2} that state that
if the pointed location does not change between two labels (modeled by the
predicate \CodeInline{eq}) and \CodeInline{P(x)} holds for one of them, then it
holds for the other one.



\CodeBlockInput[5][19]{c}{trigger_1_1.c}


And we want to prove the following program:


\CodeBlockInput[21][31]{c}{trigger_1_1.c}


However, we can see here that the proof fails on the following verification
condition (again we have removed what is not useful for our explanations):


\image{trigger_1_1}


Thus, the SMT solver seems to be unable to use one of the two axioms of our
definition: either it cannot show that after the call to \CodeInline{g(y)},
\CodeInline{P(x)} is still true, or it can, and thus it cannot show that it
implies that \CodeInline{Q(x)} is true. Let us try to add an assertion so that
we verify that we can prove \CodeInline{P(x)} after the call:


\CodeBlockInput[24][32]{c}{trigger_1_1p.c}



\image{trigger_1_1p}



It seems that despite the fact that it is clear that \CodeInline{*x} did not
change during the call \CodeInline{g(y)}, and thus that
\CodeInline{eq\{Pre, Here\}(x)} holds after the call, since this property is
not directly provided in this verification condition, the SMT solver does not
use the corresponding axiom \CodeInline{ax\_2}. Thus, let us provide this
information to the solver:


\CodeBlockInput[24][32]{c}{trigger_1_2.c}



Now, everything is proved as, if we have a look at the verification condition,
we can see that this important information is provided so that the SMT solver
can use it:


\image{trigger_1_2}



\levelThreeTitle{A more complex example: sort, again}



Let us now consider a more complex example that involves some actual axiomatic
definitions. This time, we will prove the insertion sort function:



\CodeBlockInput[5]{c}{insert_sort.c}


The \CodeInline{insertion\_sort} function visits each value, from the beginning
of the array, to the end. For each value $v$, it is inserted (using the
\CodeInline{insert} function) at the right place in the range of the already
sorted values (at the beginning of the array), by shifting them until it meets
a value that is smaller than $v$ or the first cell of the array.




We want to prove the same postcondition as we already proved for the selection
sort, that is: we want to create a sorted permutation of the original values.
Again, each iteration of the loop must ensure that the new configuration is a
permutation of the original values, and that the range from the beginning to
the current visited cell is sorted. All these properties are ensured by the
\CodeInline{insert} function. If we give a closer look at this function, we can
see that it records the value to insert (which is at the end of the range) in
the variable \CodeInline{value} and starting from this last position it shifts
all value until it meets a value that is smaller than the one we want to insert
or the first cell of the array, and finally inserts the value.




First, let us provide a suitable contract and loop invariant for the insertion
sort function. The contract is equivalent to the one provided for the selection
sort. Note however that the invariant is weaker: we do not need the values that
are still not visited to be greater than the visited ones: we insert each value
at the right place.



\CodeBlockInput[67][85]{c}{insert_sort-contract.c}



Now, we can provide a contract for the insert function. The function requires
that the first part of the range is already sorted from the beginning to the
penultimate, and in exchange, it guarantees that the complete final range is
sorted and is a permutation of the original one:



\CodeBlockInput[47][65]{c}{insert_sort-contract.c}



Then, we need to provide a suitable invariant to the loop of the
\CodeInline{insert} function. And this time, we can see that with our
previously defined permutation predicate, we are in trouble.
Indeed, our inductive definition of the permutation specifies three cases: a
range is permutation of itself, or two (and only two) values have been swapped,
or the permutation is transitive. But none of these cases can be applied to our
\CodeInline{insert} function, since the shifted range is not obtained by
successively exchanging values, and that the other cases obviously do not apply
here.



Thus, we need to find a better definition to the notion of permutation. We can
notice that what we really need to provide is a way to say ``each value that
was previously in the array is still in the array and if several values were
equivalent, the number of occurrences of these values does not change''. And in
fact, this last part of the expression is enough to express our permutation.
A permutation of a range is a range such that for all value, the number of
occurrences of this value in the array does not change from a program point to
another:



\CodeBlockInput[42][46]{c}{insert_sort-proved.c}



Starting from this definition, we are able to provide lemmas that allow to
reason efficiently about permutation, provided that some properties hold about
the array between two program points. For example, it would be possible to define
the case \CodeInline{Swap} in our previous inductive definition using a lemma.
And it is of course also possible for our shifted range.




Let us determine what are the required lemmas by first considering the
\CodeInline{insert\_sort} function. The only property that is not proved is the
invariant of the loop that expresses the fact that the array is a permutation of
the original array. How can we deduce it? (We will consider the proofs of the
lemmas later).




We can observe two facts: the first range in the array (from \CodeInline{beg} to
\CodeInline{i+1}) is a permutation of the same range at the beginning of the
iteration (by the contract of the \CodeInline{insert} function). The second part
(from \CodeInline{i+1} to \CodeInline{end}) is unchanged, thus this is also a
permutation. Let us use some assertions to see whether we can prove this or not.
While the first property is easily deduced, we can see that the second one is
not:



\begin{CodeBlock}{c}
  /*@
    loop invariant beg+1 <= i <= end ;
    loop invariant sorted(a, beg, i) ;
    loop invariant permutation{Pre, Here}(a,beg,end);
    loop assigns a[beg .. end-1], i ;
    loop variant end-i ;
  */
  for(size_t i = beg+1; i < end; ++i) {
    //@ ghost L:
    insert(a, beg, i);
    //@ assert permutation{L, Here}(a, beg, i+1); // PROVED
    //@ assert permutation{L, Here}(a, i+1, end); // NOT PROVED
  }
\end{CodeBlock}


So we need a first lemma for this property. Let us define two predicates
\CodeInline{shifted} and \CodeInline{unchanged}, the latter being used to
define the former (we will see why later) and express that an unchanged
range is a permutation.


\CodeBlockInput[53][60]{c}{insert_sort-proved.c}

\CodeBlockInput[72][75]{c}{insert_sort-proved.c}


And now, we can verify that those two sub-arrays are permutations, this is done
by adding an assertion that shows that the range \CodeInline{i+1} to
\CodeInline{end} is unchanged, in order to trigger our lemma
\CodeInline{unchanged\_is\_permutation}.


\CodeBlockInput[134][147]{c}{insert_sort-proved.c}


Thus, since those two parts are permutations, the global array is a permutation
of the values present at the beginning of the iteration. However, this is not
directly proved, so we also need a lemma for this:



\CodeBlockInput[80][86]{c}{insert_sort-proved.c}


And now we can deduce that a loop iteration produces a permutation by adding
this conclusion as an assertion:



\begin{CodeBlock}{c}
    //@ ghost L: ;
    insert(a, beg, i);
    //@ assert permutation{L, Here}(a, beg, i+1);
    //@ assert unchanged{L, Here}(a, i+1, end);
    //@ assert permutation{L, Here}(a, i+1, end);
    //@ assert permutation{L, Here}(a, beg, end); // PROVED
\end{CodeBlock}



Finally, we need to add one more information, the permutation of a permutation
is also a permutation. This time, we do not have to add more assertions, the
context contains:
\begin{itemize}
\item \CodeInline{permutation\{Pre, L\}(a, beg, end)} (invariant)
\item \CodeInline{permutation\{L, Here\}(a, beg, end)} (assertion)
\end{itemize}
which is enough to conclude \CodeInline{permutation\{Pre, Here\}(a, beg, end)}
at the end of the loop block using the following lemma:



\CodeBlockInput[47][52]{c}{insert_sort-proved.c}



Now, we can have a closer look at the insertion function, by first considering
how to maintain that the function produces a permutation.




It shifts the different elements to the left until it reaches the beginning of
the array or an element that is smaller than the element to insert which is
initially at the end of the range, and is inserted at the reached position. The
cells from the beginning of the array to the location of insertion are left
unchanged, so this is a permutation. We have a lemma for this, but we also have
to state that the values are unchanged as an invariant of the loop. The second
part of the array is a permutation because we rotate the elements, we need a
lemma to express this, and to state at least that the element are shifted by the
loop as an invariant. Finally, the union of the two permutations is a
permutation, and we also have a lemma for this.



So first, we can give a suitable invariant for the permutation:
\begin{itemize}
\item we provide the bounds of \CodeInline{i}
\item we state that the first part is left unchanged
\item we state that the last part is shifted to the left
\end{itemize}
as well as some assertions that we want to be verified:
\begin{itemize}
\item first in order to trigger \CodeInline{unchanged\_permutation}, we place
  a first assertion that state that the first part of the array is unchanged,
  which allows to prove
\item the second one that asserts that the first part of the array is a
  permutation of the original one, and is used in combination  with ...
\item the third one that asserts that the second part of the array is a
  permutation of the original one (which allows triggering
  \CodeInline{union\_permutation} and prove the postcondition).
\end{itemize}


\begin{CodeBlock}{c}
  /*@
    loop invariant beg <= i <= last ;
    loop invariant \forall integer k ; beg <= k <= i    ==> a[k] == \at(a[k], Pre) ;
    loop invariant \forall integer k ; i+1 <= k <= last ==> a[k] == \at(a[k-1], Pre) ;

    loop assigns i, a[beg .. last] ;
    loop variant i ;
  */
  while(i > beg && a[i - 1] > value){
    a[i] = a[i - 1] ;
    --i ;
  }

  a[i] = value ;

  //@ assert unchanged{Pre, Here}(a, beg, i) ;   // PROVED
  //@ assert permutation{Pre, Here}(a, beg, i) ; // PROVED

  //@ assert rotate_left{Pre, Here}(a, i, last+1) ; //PROVED
  //@ assert permutation{Pre, Here}(a, i, last+1) ; // NOT PROVED
\end{CodeBlock}


Then, for the last assertion, we need a lemma about the rotation of the
elements:


\CodeBlockInput[61][65]{c}{insert_sort-proved.c}
\CodeBlockInput[76][79]{c}{insert_sort-proved.c}

We also have to help a bit the provers to show that the range is
sorted after the insertion. For this, we provide a new invariant to show
that the shifted values are greater than the value to insert, and then
we add some assertions to show that the array is sorted before the
insertion, that all values before the cell where we insert are lower than
the inserted value, and that the range is consequently sorted after the
insertion. Leading us to the following annotated \CodeInline{insert}
function:


\CodeBlockInput[88][124]{c}{insert_sort-proved.c}



Overall, we have 6 lemmas to prove:
\begin{itemize}
\item \CodeInline{l\_occurrences\_union}
\item \CodeInline{shifted\_maintains\_occ}
\item \CodeInline{unchanged\_is\_permutation}
\item \CodeInline{rotate\_left\_is\_permutation}
\item \CodeInline{union\_permutation}
\item \CodeInline{transitive\_permutation}
\end{itemize}

While the Coq proofs of these lemmas are beyond the scope of this tutorial (and
we will see later that in this particular case we can get rid of them), let
us give some ideas of how to prove them (nevertheless, the Coq scripts are
available on the GitHub repository of this book).


To prove \CodeInline{l\_occurrences\_union}, we reason by induction on the size
of the second part of the array, the basic case is trivial: if the size is 0, we
immediately have the equality since \CodeInline{split == to}. So now, we have
to prove that if it is true for a range of size $i$, it is true for a range of
size $i+1$. As we know that it is true until $i$ by our induction hypotheses, we
simply analyze the different cases for the last element of the range: either this
element is the one we count or not, and it adds the same value on both sides of
the equality.


For \CodeInline{shifted\_maintains\_occ}, we reason by induction on the complete
range, the first case is trivial (empty range), and for the induction case, we
just have to show the value added to the range has been shifted and is thus the
same.


The property \CodeInline{unchanged\_is\_permutation} is proved by SMT solvers
thanks to the fact that we have expressed it using \CodeInline{shifted}, then the
solver can immediately instantiate the previous lemma. If it is not the case
(depending on the version of the prover), the proof is done by instantiating
\CodeInline{shifted\_maintains\_occ} with a value of 0 for the shift property.


To prove \CodeInline{rotate\_left\_is\_permutation} we split the range at
\CodeInline{L1} into two subparts \CodeInline{beg .. beg+1} and
\CodeInline{beg+1 .. end}, and the range at \CodeInline{L2} into two subparts
\CodeInline{beg .. end-1} and \CodeInline{end-1 .. end}, using
\CodeInline{l\_occurrences\_union}. We show that the number of occurrences in
\CodeInline{beg+1 .. end} at \CodeInline{L1} and \CodeInline{beg .. end-1} at
\CodeInline{L2} did not change thanks to \CodeInline{shifted\_maintains\_occ},
and that the number of occurrences in \CodeInline{beg .. beg+1} at
\CodeInline{L1} and \CodeInline{end-1 .. end} at \CodeInline{L2} is the same by
case analysis (and using the fact that the values equal).


For \CodeInline{union\_permutation}, we instantiate the lemma
\CodeInline{l\_occurrences\_union}. Finally, the lemma
\CodeInline{transitive\_permutation} is automatically proved by SMT solvers
thanks to the transitivity of equality.


\levelThreeTitle{How to correctly use assertions?}


There is no perfect guideline on when we should use assertions or not. Most of
the time we use them to first understand why some proof fails at some point by
expressing properties that we expect to be true at some program point. Moreover,
most of the time, the verification conditions are too long and complex to be read
directly, and we somewhat have to keep in mind the different lemmas we have
already expressed and to determine whether some deduction requires the use of
a lemma that we already expressed, or if it requires to reason by induction on
some property or value such that SMT solvers cannot make this deduction, and thus
we might need to add another lemma.



With a bit of experience, the use of assertions and lemmas become more and more
natural, however one has to take care of the fact that it is easy to abuse of
these. Basically, the more we add lemmas and assertions, the more the proof
context is rich and might contain the required information to produce the proof
that we need. However, there is also a risk to add too much information so that
the proof context mainly contains garbage that is not useful for the proof but
pollute the proof context and makes the job of SMT solvers harder. Thus, we have
to find the good trade-off.


\levelThreeTitle{Exercises}


\levelFourTitle{Understanding the proof context}


In the following function, the last assertion is automatically proved by SMT
solvers, probably by unfolding the predicate and directly proving the
corresponding property. Using assertions, provide another way to prove the
last property. In the proof context, find the generated properties that could
allow to prove the assertion and explain how.


\CodeBlockInput[5]{c}{ex-1-context.c}


\levelFourTitle{Trigger lemmas}


In the following program, WP fails to prove that the postcondition of the
function \CodeInline{g} is verified. Add the right assertion (at the right
place), such that the proof succeeds.


\CodeBlockInput{c}{ex-2-trigger.c}


\levelFourTitle{Trigger lemmas, under condition}


In the following program, WP fails to prove that the postcondition of the
function \CodeInline{example} is verified. However, we can notice that the
\CodeInline{g} function indirectly ensures that the pointed value is either
increased or decreased. Add two assertions that shows which predicate holds
depending on the value of \CodeInline{*x}.


\CodeBlockInput{c}{ex-3-trigger-cond.c}


The assertions should look like:


\begin{CodeBlock}{c}
//@ assert *x ... ==> ... ;
//@ assert *x ... ==> ... ;
\end{CodeBlock}


Another way to bring some information in the context is to use ghost code.
For example, the truth value of a condition appears in the context of a
verification condition. Modify the annotation to make the code look like:


\begin{CodeBlock}{c}
void example(int* x){
  g(x);
  /*@ ghost
   if ( ... ){
    /@ assert ... @/
   } else {
    /@ assert ... @/
   }
  */
}
\end{CodeBlock}

Compare the verification condition of each assertion with the previous ones.


Finally, one can in fact notice that ``the pointed value is either increased
or decreased'' can be expressed with a single simple assertion. Write the
corresponding annotation.



\levelFourTitle{An actual example with sum}
\label{l4:proof-methodologies-triggering-lemmas-exercises-sum}


The following function increases by 1 the value of a cell in an array, thus it
also increases the value of the sum of the content of this array. Write a
contract to the function that expresses this fact.


\CodeBlockInput[5]{c}{ex-4-sum-content.c}


In order to prove that this function fulfills its contract, we need to provide
some assertions that will guide the proof. More precisely, we have to show that
since all values before the modified cell has not been modified, the sum has not
been modified in this part of the array, and same for the cells that follow the
modified cell.


Thus, we need two lemmas:
\begin{itemize}
\item \CodeInline{sum\_separable} should express that we can split an array into
  two subparts, count in each of them and sum the results to get the sum of the
  entire array,
\item \CodeInline{unchanged\_sum} should express that if a range of an array has
  not changed between two labels, the sum of the content is the same.
\end{itemize}

Complete the code of the lemmas and use assertions to ensure that they will be
used to complete the proof. We do not ask the proof of the lemmas, the Coq
proofs are available on the GitHub repository of this book.
