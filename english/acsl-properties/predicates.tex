A predicate is a property about different objects that can be true or
false. To sum up, we are writing predicates from the beginning of this
tutorial in precondition, postcondition, assertion and loop invariant.
ACSL allows us to name these predicates, as we could do for a boolean
function in C, for example. An important difference, however, is that
predicates (as well as functions that we will see later) must be pure.
For example, they cannot produce side effects by modifying a pointed
value.

These predicates can receive some parameters. Moreover, they can also
receive some C labels that will allow us to establish relations between
different program points.



\levelThreeTitle{Syntax}


Predicates are introduced using ACSL annotations. The syntax is the
following:



\begin{CodeBlock}{c}
/*@
  predicate named_predicate { Label0, Label1, ..., LabelN }(type0 arg0, type1 arg1, ..., typeN argN) =
    //a logic relations between all these things
*/
\end{CodeBlock}



For example, we can define the predicate that checks whether an integer
in memory is changed between two particular program points:



\begin{CodeBlock}{c}
/*@
  predicate unchanged{L0, L1}(int* i) =
    \at(*i, L0) == \at(*i, L1);
*/
\end{CodeBlock}



\begin{Warning}
  Keep in mind that passing a value to a predicate is done, as it is done in C,
  by value. We cannot write this predicate by directly passing \texttt{i} in
  parameter:

\begin{CodeBlock}{c}
/*@
  predicate unchanged{L0, L1}(int i) =
    \at(i, L0) == \at(i, L1);
 */
\end{CodeBlock}

  Since \texttt{i} is just a copy of the received variable.
\end{Warning}


We can verify this code using our predicate:



\begin{CodeBlock}{c}
int main(){
  int i = 13;
  int j = 37;

 Begin:
  i = 23;
 
  //@assert ! unchanged{Begin, Here}(&i);
  //@assert   unchanged{Begin, Here}(&j);
}
\end{CodeBlock}



We can also have a look at the goals generated by WP and notice that,
even it is slightly (syntactically) modified, the predicate is not
unrolled by WP. The provers will determine if they need to use the
definition of the predicate.

As we said earlier, one important use of predicates (and logic
functions) is to make our specifications more readable and to factor it.
An example can be to write a predicate that expresses the validity of an
array in read or write. It allows us to avoid writing the complete
expression every time we need it and to make it readable quickly:



\CodeBlockInput[3]{c}{search.c}



In this specification, we do not give an explicit label to predicates
for their definition, nor for their use. For the definition, Frama-C
automatically creates an implicit label. At predicate use, the given
label is implicitly \texttt{Here}. The fact we do not explicitly define
the label in the definition of a predicate does not forbid to explicitly
give a label when we use it.

Of course, predicates can be defined in header files in order to produce
a utility library for specification for example.



\levelFourTitle{Predicate overloading}



It is possible to overload predicates as long as the types of the
parameters are different or the number of parameters changes. For
example, we can redefine the \CodeInline{valid\_range\_ro} as a
predicate that takes in parameters both the beginning and the end
of the range to consider. Then, we can write a overloaded version that
uses the previous one for the particular case of ranges that starts
at 0:



\CodeBlockInput[3]{c}{search-overload.c}




\levelThreeTitle{Abstraction}


An other important use of predicates is to define the logical state of
our data structures when programs start to be more complex. Our data
structures must usually respect an invariant (again) that each
manipulation function must maintain in order to ensure that the data
structure will always remain coherent and usable through future calls.



It allows us to ease the reading of specifications. For example, we can
define the specification required to ensure the safety of a fixed size
stack. It could be done as illustrated here:



\CodeBlockInput{c}{stack.c}



Here, the specification does not express functional properties. For
example, we do not specify that when we perform the push of a value, and
then we ask for the top of the stack, we get the same value. But we
already have enough details to ensure that, even if we cannot prove that
we always get the right result (behaviors such as ``if I push \(v\), top
returns \(v\)''), we can still guarantee that we do not produce runtime
errors (if we provide correct predicates for the stack, and prove
that the implementation of our functions ensures that no runtime errors
can occur).


\levelThreeTitle{Exercises}


\levelFourTitle{Days of the month}


Taking back the solution of the
exercise~\ref{l4:contract-modularity-ex-days-of-month} about days of the month,
write a predicate to express that a year is leap and adapt the contracts using
it.


\levelFourTitle{Alpha-numeric character}


Taking back the solution of the
exercise~\ref{l4:contract-modularity-ex-alpha-num} about alpha numeric
characters, write predicates to express that a character is an upper letter,
lower letter, and a digit. Adapt the contracts of the different functions using
them.


\levelFourTitle{Order 3 values}


Taking back the solution of the
exercise~\ref{l4:contract-modularity-ex-order-3} about the function that orders
three pointed values, write predicates to express that a value is one of three
pointed values:

\begin{CodeBlock}{c}
/*@
  predicate one_of{L}(int value, int *a, int *b, int *c) =
    // ...
*/
\end{CodeBlock}

Use the set notation. With the same idea, express permutation. Modify the
contract in order to use these predicates.


\levelFourTitle{Binary Search}


Taking back the solution of the
exercise~\ref{l4:statements-loops-ex-bsearch} about the binary search
function, write a predicate that expresses that an array is sorted on a range of
values starting at \CodeInline{begin} and ending at \CodeInline{end} (excluded).
Overload this predicate in order to make \CodeInline{begin} optional with a
default value of $0$. Define a predicate that an element is in a range of values
of an array starting at index \CodeInline{begin} and ending at \CodeInline{end}
(excluded), again overload this predicate to make the first bound optional.

Use those two predicates to simplify the contract of the function. Note that
both behaviors \CodeInline{assumes} clause should be modified.


\levelFourTitle{Search and replace}



Taking back the example~\ref{l4:statements-loops-ex-search-and-replace}, about
the search and replace function, write predicates that express that some range
of values of an array starting at index \CodeInline{begin} and ending at
\CodeInline{end} (excluded):

\begin{itemize}
\item remain unchanged between to labels,
\item are replaced with some new value when it equals to some old value, then
  left unchanged
\end{itemize}

Overload both predicates to make the first bound optional. Use the obtained
predicates to simplify the contract and loop invariant of the function.
