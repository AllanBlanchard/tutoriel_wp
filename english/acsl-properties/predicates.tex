A predicate is a property about different objects that can be true or
false. To sum up, we are writing predicates from the beginning of this
tutorial in precondition, postcondition, assertion and loop invariant.
ACSL allows us to name these predicates, as we could do for a boolean
function in C, for example. An important difference, however, is that
predicates (as well as logic functions that we will see later) must be pure.
For example, they cannot produce side effects by modifying a pointed
value.

These predicates can receive some parameters. Moreover, they can also
receive some C labels that will allow us to establish relations between
different program points.



\levelThreeTitle{Syntax}


Predicates are introduced using ACSL annotations. The syntax is the
following:



\begin{CodeBlock}{c}
/*@
  predicate named_predicate { Lbl0, ..., LblN }(type0 arg0, ..., typeN argN) =
    //a logic relations between all these things
*/
\end{CodeBlock}



For example, we can define the predicate that checks whether an integer
in memory is changed between two particular program points:



\CodeBlockInput[6][9]{c}{unchanged-loc.c}



\begin{Warning}
  Keep in mind that passing a value to a predicate is done, as it is done in C,
  by value. We cannot write this predicate by directly passing \texttt{i} in
  parameter:

\begin{CodeBlock}{c}
/*@
  predicate unchanged{L0, L1}(int i) =
    \at(i, L0) == \at(i, L1);
 */
\end{CodeBlock}

  Since \texttt{i} is just a copy of the received variable.
\end{Warning}


We can verify this code using our predicate:



\CodeBlockInput[11][20]{c}{unchanged-loc.c}



We can also have a look at the verification conditions generated by WP and
notice that, even it is slightly (syntactically) modified, the predicate is not
unrolled by WP. The provers will determine themselves whether they need to use
the definition of the predicate to establish the proof.



\image{unchanged-loc}



As we said earlier, one important use of predicates (and logic
functions) is to make our specifications more readable and to factor it.
An example can be to write a predicate that expresses the validity of an
array in reading or writing. It allows us to avoid writing the complete
expression every time we need it and to make it readable quickly:



\CodeBlockInput[7]{c}{search.c}



In this specification, we do not give an explicit label to predicates
for their definition, nor for their use. For the definition, Frama-C
automatically creates an implicit label. At predicate use, the given
label is implicitly \texttt{Here}. The fact we do not explicitly define
the label in the definition of a predicate does not forbid to explicitly
give a label when we use it.

Of course, predicates can be defined in header files in order to produce
a utility library for specification for example.



\levelFourTitle{Predicate overloading}



It is possible to overload predicates as long as the types of the
parameters are different or the number of parameters changes. For
example, we can redefine the \CodeInline{valid\_range\_r} as a
predicate that takes in parameters both the beginning and the end
of the range to consider. Then, we can write an overloaded version that
uses the previous one for the particular case of ranges that starts
at 0:



\CodeBlockInput[7]{c}{search-overload.c}




\levelThreeTitle{Abstraction}


An other important use of predicates is to define the logical state of
our data structures when programs start to be more complex. Our data
structures must usually respect an invariant (again) that each
manipulation function must maintain in order to ensure that the data
structure will always remain coherent and usable through future calls.



It allows us to ease the reading of specifications. For example, we can
define the specification required to ensure the safety of a fixed size
stack. It could be done as illustrated here (note that we do not
provide the definition of the predicates as it is not the purpose of
our example, the careful reader could consider this as an exercise):



\CodeBlockInput[5]{c}{stack.c}



Here, the specification does not express functional properties. For
example, we do not specify that when we perform the push of a value, and
then we ask for the top of the stack, we get the same value. But we
already have enough details to ensure that, even if we cannot prove that
we always get the right result (behaviors such as ``if I push \(v\), top
returns \(v\)''), we can still guarantee that we do not produce runtime
errors (if we provide correct predicates for the stack, and prove
that the implementation of our functions ensures that no runtime errors
can occur).


\levelThreeTitle{Exercises}


\levelFourTitle{Days of the month}


Taking back the solution of the
exercise~\ref{l4:contract-modularity-ex-days-of-month} about days of the month,
write a predicate to express that a year is leap and adapt the contracts using
it.


\levelFourTitle{Alpha-numeric character}


Taking back the solution of the
exercise~\ref{l4:contract-modularity-ex-alpha-num} about alpha numeric
characters, write predicates to express that a character is an upper letter,
lower letter, and a digit. Adapt the contracts of the different functions using
them.


\levelFourTitle{Max of 3 values}


The following function returns the max of 3 input values:


\CodeBlockInput[5]{c}{ex-3-max-3.c}


Write a predicate to express that a value is one of three pointed values at a
given memory state:

\begin{CodeBlock}{c}
/*@
  predicate one_of{L}(int value, int *a, int *b, int *c) =
    // ...
*/
\end{CodeBlock}

Use the set notation. Write a contract to the function and prove that it is
verified.


\levelFourTitle{Binary Search}
\label{l4:acsl-properties-predicates-ex-bsearch}


Taking back the solution of the
exercise~\ref{l4:statements-loops-ex-bsearch} about the binary search function
with unsigned types, write a predicate that expresses that an array is sorted on
a range of values starting at \CodeInline{begin} and ending at \CodeInline{end}
(excluded). Overload this predicate in order to make \CodeInline{begin} optional
with a default value of $0$. Define a predicate that checks if an element is in
a range of values of an array starting at index \CodeInline{begin} and ending at
\CodeInline{end} (excluded), again overload this predicate to make the first
bound optional.

Use those two predicates to simplify the contract of the function. Note that
both behaviors \CodeInline{assumes} clause should be modified.


\levelFourTitle{Search and replace}



Taking back the example~\ref{l4:statements-loops-ex-search-and-replace}, about
the search and replace function, write predicates that express that in some range
of an array starting at index \CodeInline{begin} and ending at \CodeInline{end}
(excluded), values

\begin{itemize}
\item remain unchanged between two labels,
\item are replaced with some new value when it equals to some old value, then
  left unchanged
\end{itemize}

Overload both predicates to make the first bound optional. Use the obtained
predicates to simplify the contract and loop invariant of the function.
