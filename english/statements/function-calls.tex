\levelThreeTitle{Calling a function}

\levelFourTitle{Formal - Weakest precondition calculus}

When a function is called, the contract of this function is used to determine
the precondition of the call. But one has to consider two important facts to
express the weakest precondition calculus.



First, the postcondition of the called function $f$ is not necessarily
directly the precondition that was computed for the instructions that follow
the call to $f$. For example, if we have a program: \CodeInline{x = f() ; c }
and $wp(\texttt{c}, Q) = 0 \leq x \leq 10$, whereas the postcondition of the
function \CodeInline{f} is $1 \leq x \leq 9$, we have to express some
weakening between the actual precondition of \CodeInline{c} and the computed
one. For this, we refer to the section~\ref{l3:statements-basic-consequence},
the idea is simply to verify that the postcondition of the function implies
the computed precondition.



Second, in C, a function can have side-effects. Thus, the values of the
variables referenced in input are not necessarily the same as they was after the
call to the function, and the contract may express some property about those
values before and after the call. So, if we have labels in the postcondition,
we must correctly replace them.



In order to define the weakest-precondition calculus of function calls, let
us introduce some notation to make things clearer. For this, consider this
example:


\begin{CodeBlock}{c}
/*@ requires \valid(x) && *x >= 0 ;
    assigns *x ;
    ensures *x == \old(*x)+1 ; */
void inc(int* x);

void foo(int* a){
  L1:
  inc(a) ;
  L2:
}
\end{CodeBlock}




The weakest precondition of the function call asks us to consider the contract
of the function that is called (here, in \CodeInline{foo}, when we call the
\CodeInline{inc} function). Of course, before the call to the function we have
to verify its precondition, so it is part of the weakest precondition. But, we
also have to consider the postcondition of the function, else that would mean
that we do not consider its effect.




Thus, it is important to notice that in the precondition, the considered memory
state is the one where we compute the weakest precondition, whereas for the
postcondition it is not the case, the considered memory state is the one that
follows the call, while we need to explicitly mention the old state to speak
about the values before the call. For example, considering the contract of
\CodeInline{inc} when we call it in \CodeInline{foo}, \CodeInline{*x} in the
precondition is \CodeInline{*a} at \CodeInline{L1}, while \CodeInline{*x} in the
postcondition is \CodeInline{*a} at \CodeInline{L2}. Consequently the pre and
the postcondition must be considered slightly differently when it comes to
mutable memory location. Note that for the value of the parameter \CodeInline{x}
itself, there is no such consideration: this value cannot be modified by the
call.




Now, let us define the weakest precondition of a function call. For this,
we denote:

\begin{itemize}
\item $\vec{v}$ a vector of values $v_1, ..., v_n$ and $v_i$ the $i^{th}$ value,
\item $\vec{t}$ the arguments provided to the function when we call it,
\item $\vec{x}$ the parameters in the function definition,
\item $\vec{a}$ the assigned values (seen from the outside, once instantiated),
\item $here(x)$ a value in postcondition
\item $old(x)$ a value in precondition
\end{itemize}

We name $\texttt{f:Pre}$ the precondition of the function, and $\texttt{f:Post}$
the postcondition:



\begin{center}
\begin{tabular}{rl}
  $wp( f(\vec{t}), Q ) :=$ & $\texttt{f:Pre}[x_i \leftarrow t_i]$ \\
  $\wedge$ & $\forall \vec{v}, \quad (
              \texttt{f:Post}[x_i \leftarrow t_i,
                              here(a_j) \leftarrow v_j,
                              old(a_j) \leftarrow a_j] \Rightarrow
              Q[here(a_j) \leftarrow v_j])$
\end{tabular}
\end{center}


We can detail a little bit the reasoning for each part of this formula.


First, note that in both pre and postcondition, each named parameter $x_i$ is
replaced with the corresponding argument ($[x_i \leftarrow t_i]$), as we said
before we do not have to consider memory states there because those values
cannot be changed by the function call. For example in the contract of
\CodeInline{inc}, each \CodeInline{x} would be replaced by the argument
\CodeInline{a}.



Then, in the part of the formula that corresponds to the postcondition, we can
see that we introduce a $\forall \vec{v}$. The goal is here to model the fact
that the function can write any value in each memory location that is assigned.
So, for each of the assigned location $a_j$ (that is for our call to
\CodeInline{inc}, \CodeInline{*(\&a)}), we generate a value $v_j$ that is its
value after the call. But, if we want to check that the postcondition gives us
the right result, we cannot accept \emph{any value} for each assigned location,
we just want the ones \emph{that allows to satisfy the postcondition}.



So these values are used to transform the postcondition of the function and
verify that it implies the postcondition in input of the weakest precondition.
This is done by replacing, for each assigned location $a_j$, its value $here$
with the value $v_j$ that it is supposed to get after the call
($here(a_j) \leftarrow v_j$). Finally, we have to replace each $old$ value by
its value before the call, and for each $old(a_j)$, it is simply $a_j$
($old(a_j) \leftarrow a_j$).



\levelFourTitle{Formal - Example}



Let us illustrate this on an example by applying the weakest precondition
calculus to this short code, assuming the contract we previously proposed for
the \CodeInline{swap} function.



\begin{CodeBlock}{c}
  int a = 4 ;
  int b = 2 ;

  swap(&a, &b) ;

  //@ assert a == 2 && b == 4 ;
\end{CodeBlock}



We now compute the weakest precondition:


\begin{tabular}{l}
  $wp(a = 4; b = 2; swap(\&a, \&b), a = 2 \wedge b = 4) = $\\
  $\quad wp(a = 4, wp(b = 2; swap(\&a, \&b), a = 2 \wedge b = 4)) = $\\
  $\quad wp(a = 4, wp(b = 2, wp(swap(\&a, \&b), a = 2 \wedge b = 4)))$
\end{tabular}


Let us first consider separately:


$$wp(swap(\&a, \&b), a = 2 \wedge b = 4)$$



From this \CodeInline{assigns} clause, we know that the assigned values are
$*(\&a) = a$ and $*(\&b) = b$. (Let us shorten $here$ with $H$ and $old$ with
$O$).


\begin{tabular}{rl}
  $\quad \quad \texttt{swap:Pre}[x \leftarrow \&a,\ y \leftarrow \&b]$ & \\
  $\quad \wedge \forall v_a, v_b,(\texttt{swap:Post}$ & $ [ x \leftarrow \&a,\ y \leftarrow \&b, $ \\
                               & $H(*(\&a)) \leftarrow v_a,\ H(*(\&b)) \leftarrow v_b,$ \\
                               & $O(*(\&a)) \leftarrow *(\&a),\ O(*(\&b)) \leftarrow *(\&b)])$\\
  \multicolumn{2}{r}{$\quad \quad \Rightarrow (H(a) = 2 \wedge H(b) = 4)[H(a)) \leftarrow v_a, H(b)) \leftarrow v_b])$}
\end{tabular}


For the precondition, we get :
$$valid(\&a) \wedge valid(\&b)$$
For the postcondition part, let us first write the expression from which
we start before any term replacement (and without the syntax for the
replacement for the sake of conciseness):
$$H(*x) = O(*y) \wedge H(*y) = O(*x) \Rightarrow H(a) = 2 \wedge H(b) = 4$$
First we replace the pointers ($x \leftarrow \&a,\ y \leftarrow \&b$) :
$$H(*(\&a)) = O(*(\&b)) \wedge H(*(\&b)) = O(*(\&a)) \Rightarrow H(a) = 2 \wedge H(b) = 4$$
Then, the $here$ values, with the quantified $v_i$s ($H(a)) \leftarrow v_a, H(b)) \leftarrow v_b$):
$$v_a = O(*(\&b)) \wedge v_b = O(*(\&a)) \Rightarrow v_a = 2 \wedge v_b = 4$$
And the $old$ values, with the value before call
($O(*(\&a)) \leftarrow *(\&a),\ O(*(\&b)) \leftarrow *(\&b)$):
$$v_a = *(\&b) \wedge v_b = *(\&a) \Rightarrow v_a = 2 \wedge v_b = 4$$
We can now simplify this formula to:
$$v_a = b \wedge v_b = a \Rightarrow v_a = 2 \wedge v_b = 4$$


So, $wp(swap(\&a, \&b), a = 2 \wedge b = 4)$ is:
$$P: valid(\&a) \wedge valid(\&b) \wedge \forall v_a, v_b, \quad v_a = b \wedge v_b = a \Rightarrow v_a = 2 \wedge v_b = 4$$
Let us immediately simplify the formula by noticing that validity properties
are trivially true here (since the variable are allocated on the stack just
before):
$$P: \forall v_a, v_b, \quad v_a = b \wedge v_b = a \Rightarrow v_a = 2 \wedge v_b = 4$$


Let us now compute $wp(a = 4, wp(b = 2, P)))$, by first replacing $b$ with
$2$ by the assignment rule:
$$\forall v_a, v_b, \quad v_a = 2 \wedge v_b = a \Rightarrow v_a = 2 \wedge v_b = 4$$
and then replacing $a$ with $4$ by the same rule:
$$\forall v_a, v_b, \quad v_a = 2 \wedge v_b = 4 \Rightarrow v_a = 2 \wedge v_b = 4$$


This last property is trivially true, thus the program is verified.



\levelFourTitle{What should we keep in mind?}



Functions are absolutely necessary to modular programming, and the weakest
precondition calculus is fully compatible with this idea, allowing to reason
about each function locally and compose proofs just as we compose function
calls.


So as a reminder, we should just keep in mind the following general scheme:



\begin{CodeBlock}{c}
/*@
  requires foo_R ;
  assigns ... ;
  ensures foo_E ;
*/
type foo(parameters...){
  // Here we suppose that foo_R holds


  // Here we must prove that bar_R holds
  bar(some parameters ...) ;
  // Here we assume that bar_E holds


  // Here we must prove that foo_E holds
  return ... ;
}
\end{CodeBlock}


Note that for the last statement, with weakest precondition calculus, the idea
is more to show that our precondition is strong enough to ensure that the code
leads to our postcondition. However, first, this vision is simpler to
understand, and second the WP plugin does not actually perform a strict weakest
precondition calculus but a highly optimized one that does not follow exactly
the same rules.


\levelThreeTitle{Recursive functions}


Just as it is easy to prove anything about a function if it contains an
infinite loop, it is easy to prove anything about a function that does an
infinite recursion:


\CodeBlockInput{c}{trick.c}


\image{recursive-trick}


We can see that the function and the assertion are proved. And indeed the
proof is correct: we consider partial correctness, and we face a function
that does not terminate: anything that follows a call to this function would
be true.


Thus, the question is: what could we do in such a case? Again, we could use
some kind of variant to bound the depth of the recursive calls. In ACSL, it is
expressed through the \CodeInline{decreases} clause:



\CodeBlockInput{c}{decreases.c}


This clause expresses exactly the same idea as a \CodeInline{loop variant}.
The expression considered by a \CodeInline{decreases} clause is a positive
integer expression (or an expression equipped with a relation) that strictly
decreases when the function is called again.



Let us emphasize on the fact that the \CodeInline{decreases} clause really
bounds the depth of the recursion and not the number of calls:



\begin{CodeBlock}{c}
/*@ requires n >= 0 ;
    decreases n ;
*/
void ends(int n){
  if(n > 0) ends(n-1); // Ok: 0 <= n-1 < n
  if(n > 0) ends(n-1); // Ok: 0 <= n-1 < n, no need to be less than call on l.5
}
\end{CodeBlock}



Note than, just like evaluation of the \CodeInline{terminates} clause, the
clause of the function under verification is evaluated at \CodeInline{Pre}
state:


\begin{CodeBlock}{c}
/*@ requires *p >= 0 ;
    decreases *p ;
*/
void ends(int *p){
  if(*p > 0){
    (*p)-- ;
    ends(p); // Ok: 0 <= *p < \at(*p, Pre);
  }
}
\end{CodeBlock}



Of course, recursive functions can be mutually recursive thus the
\CodeInline{decreases} can be used to bound recursive function calls in this
situation. But, we only want to do so {\em only} for functions that are indeed
in the set of functions that are involved in the recursion. For this, WP
computes the strongly connected components from the set of functions, this is
called a {\em cluster}.


\begin{Information}
  Note that this is done syntactically, for now we do not cover function
  pointers in this tutorial, but one can refer to the option
  \CodeInline{-wp-dynamic} in the WP manual.
\end{Information}


Thus, let us be more precise about the verification of the \CodeInline{decreases}
clause. When a function is (mutually) recursive, it must be equipped with such
a clause to prove that it terminates. Verifying that the \CodeInline{decreases}
clause of a function \CodeInline{f} gives a measure is done by checking for each
call to a function {\em that belongs to the same cluster as \CodeInline{f}},
that the expression is indeed positive and decreasing. And thus, no proof
obligation is generated when calling a recursive function that does not belong
to the same cluster:


\begin{CodeBlock}{c}
//@ decreases v ;
void s(unsigned v){
  if(v > 0) s(v-1); // OK: 0 <= v-1 < v
}

//@ decreases k-1 ;
void m2(unsigned k);

//@ decreases n ;
void m1(unsigned n){
  if(n > 1) m2(n-1); // OK: 0 <= (n-1)-1 < n ;
}

void m2(unsigned k){
  if(k > 1) m1(k-2); // OK: 0 <= (k-2) < k-1 ;
  s(k+1) ; // no verification needed, s in not in the cluster
}
\end{CodeBlock}


Finally, if a function of a cluster does not have a \CodeInline{decreases}
clause, a \CodeInline{\textbackslash{}false} verification condition is generated
and a warning is emitted by WP.


% add an example
\levelThreeTitle{Specifying and proving function termination}



A desirable property of function is often that it should terminate. Indeed, in
most programs, all functions must terminate and when it is not the case and that
some functions can loop forever, it is highly common that there is a single
function that is allowed to loop forever (so almost all functions in this
program must terminate).



\levelFourTitle{Syntax and description}



ACSL provides a way to specify that a function must terminate when some property
is verified in precondition. The syntax is:



\begin{CodeBlock}{c}
//@ terminates condition ;
void function(void){
  // ...
}
\end{CodeBlock}



It states that when \CodeInline{condition} is verified in precondition, then
the function must terminate. For example, function \CodeInline{abs} must always
terminate:



\begin{CodeBlock}{c}
//@ terminates \true ;
int abs(int x){
  return (x < 0) ? -x : x ;
}
\end{CodeBlock}



while function \CodeInline{main\_loop} may not:



\begin{CodeBlock}{c}
int debug_steps = -1 ;

/*@ requires debug_steps >= -1 ;
    terminates debug_steps > 0 ;
 */
void main_loop(void){
  /*@ loop invariant debug_steps == -1
                  || 0 <= debug_steps <= \at(debug_steps, Pre) ;
      loop assigns debug_steps ;
      loop variant debug_steps ; */
  while(1){
    if(debug_steps == 0) return ;
    else debug_steps -- ;

    // actual code
  }
}
\end{CodeBlock}



Let us emphasize on the fact that the function {\em may not} terminate, it is
not {\em forced to loop forever}. For example, in the following function, the
\CodeInline{terminates} clause is verified since
{\em when the termination condition is verified} (never), the function
terminates (always):



\begin{CodeBlock}{c}
//@ terminates \false ;
void function(void){

}
\end{CodeBlock}



\begin{Information}
  If one really wants to verify that some function never terminates, it can be
  done by specifying that the \CodeInline{return} and the \CodeInline{exit}
  conditions are unreachable:
  \begin{CodeBlock}{c}
/*@ terminates \false;
    exits \false;
    ensures \false;
*/
void does_not_terminate(void){
  //@ loop assigns some_variables ;
  while(1){
    // ... code
  }
}\end{CodeBlock}
\end{Information}



\levelFourTitle{Verification}



Verifying that a function terminates asks to verify that all reachable
statements of the function terminate. Assignments trivially terminate, thus
we do not have something particular to do for them. A conditional statement
terminates if all statements in different branches terminate, thus we just
have to verify that these statements terminate. The remaining statements are
loops and function calls. Thus, we have to verify that:



\begin{itemize}
  \item all loops have a (verified) \CodeInline{loop variant} clause,
  \item all functions that are called terminate with the given parameters,
  \item all recursive functions have a (verified) \CodeInline{decreases} clause,
  \item (or that there are no loops or calls in the function).
\end{itemize}



However, we only have to do that when the termination condition of the function
is verified. So let us now explain what are the generated verification
conditions and when does WP generate them.



When a function has a \CodeInline{terminates} clause, WP visits all statements
and collects the loops that do not have a \CodeInline{loop variant} clause and
the function calls. If there are none of them, the \CodeInline{terminates}
clause is trivially verified.



% add a screenshot here



When there are such statements, their termination must be verified {\em when}
the function must terminate (say, when \CodeInline{T}). Thus, the verification
conditions are of the form
\CodeInline{\textbackslash{}at(T, Pre)} $\Rightarrow$ \CodeInline{<statement termination>}.
One should note that the premise of the implication is evaluated at the
\CodeInline{Pre} state. Thus, in this code:



\begin{CodeBlock}{c}
//@ terminates r > 0 ;
void function(int r){
  r -- ;
  call();
}
\end{CodeBlock}



Even if \CodeInline{r} has been decremented, the verification of the
termination of \CodeInline{call()} is done with \CodeInline{r > 0} as a
premise.



Note also that it means that when we reach a program point when \CodeInline{T}
is false, the verification condition is always verified:



\begin{CodeBlock}{c}
//@ terminates r > 0 ;
void function(int r){
  if(r <= 0){ // if we enter here, r > 0 is false at Pre
    // here statements are not force to terminate: FALSE ==> P is always true
  }
}
\end{CodeBlock}



\paragraph{Function call}



Verifying that a function call terminates is done by verifying that when it is
called, its termination condition is true. For example:



\begin{CodeBlock}{c}
//@ terminates value > 0 ;
void callee(int value);

//@ terminates p > 0 ;
void caller(int p){
  // goal: p > 0 ==> p+1 > 0 ; (provable)
  callee(p+1);
  // goal: p > 0 ==> p-1 > 0 ; (not provable, the function may not terminate)
  callee(p-1);
}
\end{CodeBlock}



% add screenshots
% PO  provable
% PO !provable



When the called function does not have a \CodeInline{terminates} clause, it
is considered to be \CodeInline{\textbackslash{}false}, that is: unless a
\CodeInline{terminates} clause is provided, the function may not terminate.


% add screenshot


\begin{Information}
  In ACSL, it is specified that when a function does not have a
  \CodeInline{terminates} clause, the default is
  \CodeInline{terminates \textbackslash{}true}, however it is still not
  implemented by the Frama-C kernel. This behavior can be enabled in WP
  by using the options:
  \begin{itemize}
  \item \CodeInline{-wp-definitions-terminate} (for functions with definition),
  \item \CodeInline{-wp-declarations-terminate} (for functions without definition),
  \item \CodeInline{-wp-frama-c-stdlib-terminate} (for functions of the Frama-C stdlib).
  \end{itemize}
  to claim that, unless a clause is provided, they must terminate (and thus
  for functions with a definition, the verification must be performed.
\end{Information}


\paragraph{Loop variant}



When a function contains a loop that does not have a \CodeInline{loop variant}
clause, its termination cannot be verified, thus WP asks us to verify that when
the termination condition is verified, this loop is unreachable.



\begin{CodeBlock}{c}
//@ terminates value > 0 ;
void function(int value){
  if(value <= 0){
    //@ loop assigns world ;
    while(1){
      // code
    }
  }
}
\end{CodeBlock}



In the previous code, the loop does not have a \CodeInline{loop variant}
clause, thus we have to verify \CodeInline{value > 0 ==> \textbackslash{}false}
at the loop location, which is OK: this code is unreachable when
\CodeInline{value > 0}.



Finally, when a loop has a \CodeInline{loop variant} clause, it must be
verified {\em only when} the function must terminate. So in the example
we presented at the beginning of this section:



% example with main loop



We have to verify that the loop variant is positive decreasing value only
when \CodeInline{debug\_steps} is not $-1$. However, this is not the default
behavior of WP (that always verify loop variants by default), this can
be enabled using the option \CodeInline{-wp-variant-with-terminates} and
in this case our function is entirely verified:



% add screenshot


\paragraph{Recursion}


The behavior for recursive functions is similar to loops: a recursive function
should have a \CodeInline{decreases} clause when its specification states that
it terminates. If such a clause is missing, a verification condition:
\CodeInline{\textbackslash{}at(T, Pre)} $\Rightarrow$ \CodeInline{\textbackslash{}false}
is generated.


% add an example


Again in ACSL, the verification of the \CodeInline{decreases} clause
verification is required only when the termination condition is verified in
\CodeInline{Pre} state. The behavior of WP on this aspect is similar to the
\CodeInline{loop variant}. By default, the verification is always tried, the
ACSL specified behavior is enabled via the option
\CodeInline{-wp-variant-with-terminates}.


% add an example
