From the beginning of this tutorial, we have used different predicates
and logic functions provided by ACSL: \CodeInline{\textbackslash{}valid},
\CodeInline{\textbackslash{}valid\_read}, \CodeInline{\textbackslash{}separated},
\CodeInline{\textbackslash{}old} and \CodeInline{\textbackslash{}at}. There are others
built-in predicates, but we will not present them all, the reader can refer to
\externalLink{the documentation (ACSL implementation)}{https://frama-c.com/html/get-frama-c.html}
(note that not everything is necessarily supported by WP).



ACSL allows us to do something more than ``just'' specify our code using
existing predicates and functions. We can define our own predicates,
functions, relations, etc. Doing this, we can have more abstract
specifications. It also allows us to factor out common specifications (for example
defining what is a valid array), which has two pleasant consequences:
our specifications are more readable and more understandable, and we can
reuse existing proofs to ease the proof of new programs.



\begin{levelTwo}
  {Some logical types}
  {some-logical-types}
\end{levelTwo}

\begin{levelTwo}
  {Predicates}
  {predicates}
\end{levelTwo}

\begin{levelTwo}
  {Logic functions}
  {functions}
\end{levelTwo}

\begin{levelTwo}
  {Lemmas}
  {lemmas}
\end{levelTwo}

\horizontalLine
\newpage

In this part of the tutorial, we have seen different ACSL constructs that
allow us to factor out our specifications and to express general properties
that can be used by our solvers to make their task easier.




All techniques we have talked about are safe, since they do not \emph{a
priori} allow us to write false or contradictory specifications. At
long as the specification only uses these logic constructs, and 
as long as every lemma, precondition (at callsites), postcondition,
assertion, variant and invariant are correctly proved, then the code is
correct.




However, sometimes such constructs are not enough to express all
properties we want to express about our programs. The next constructs
we will see give us some new expressive possibilities, but it will be
necessary to be extremely careful using them, as an error would allow us
to introduce false assumptions or silently modify the program we are
verifying.
